# -*- coding: utf-8 -*-
"""
Created on Thu Sep 21 14:24:58 2023

@author: Mieszko Ferens

Script to run an experiment for modelling an XOR Arbiter PUF integrated into a
QKD system while attemping to decode the PUF response through guessing of
random data bits.
"""

import argparse
import pandas as pd
from pathlib import Path

import numpy as np
from pypuf.simulation import XORArbiterPUF
import pypuf.attack

class ChallengeResponseSet():
    def __init__(self, n, challenges, responses):
        self.challenge_length = n
        self.challenges = challenges
        self.responses = np.expand_dims(
            np.expand_dims(responses,axis=1),axis=1)

def main():
    
    # Set-up logging
    import logging
    logging.basicConfig(level=logging.INFO)
    
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("--outdir", type=str, default="./Results/")
    parser.add_argument("--seed", type=int, default=0, help="Random seed.")
    parser.add_argument("--n-bits", type=int, default=64,
                        help="Challenge length in bits.")
    parser.add_argument("--k", type=int, default=1,
                        help="The number of parallel APUF in the XOR PUF.")
    parser.add_argument("--train-data", type=int, default=1000000,
                        help="Number of training data samples for the model.")
    parser.add_argument("--test-data", type=int, default=10000,
                        help="Number of testing data samples for the model.")
    parser.add_argument("--batch-size", type=int, default=50000,
                        help="Number of samples to use per iteration of the" +
                        "algorithm.")
    parser.add_argument("--bias", type=int, default=0.6,
                        help="The ratio of 1s to 0s of the PUF (uniformity)." +
                        "This parameter is unused in the current version.")
    args = parser.parse_args()
    
    # Generate the PUF
    puf = XORArbiterPUF(args.n_bits, args.k, args.seed)
    
    # Generate the RNG
    rng = np.random.default_rng(seed=args.seed)
    
    # Claculate the number of batches for training in the algorithm
    n_batches = int(args.train_data/args.batch_size)
    
    # Generate independent testing CRPs (key to decode by Eve)
    test_x = 2 * np.random.randint(
        0, 2, (args.test_data, args.n_bits), dtype=np.int8) - 1
    test_y = np.expand_dims(0.5 - 0.5*puf.eval(test_x), axis=1)
    accuracies = []
    
    ### --- Algorithm ---
    
    ## -- Step 1: Collect data passively from classical channel
    
    # Bits generated by Alice (not visible to Eve)
    bits = rng.integers(low=0, high=2, size=args.train_data)
    
    # PUF challenges (visible to Eve) and responses (not visible to Eve)
    challenges = 2 * np.random.randint(
        0, 2, (args.train_data, args.n_bits), dtype=np.int8) - 1
    responses = puf.eval(challenges)
    
    # Emulate a PUF with specific bias
    # TODO: Select a subset of challenge to emulate a specifc bias value
    
    # Encoded bits generated by Alice (visible to Eve)
    encoded = np.logical_xor(bits > 0, responses.flatten() > 0)
    
    ## -- Step 2: Create initial model through PUF bias --
    
    batch = 0 # Iteration counter
    
    # Random bits guessed by Eve
    bit_guess = rng.integers(low=0, high=2, size=args.batch_size)
    
    # Bits decoded by Eve to obtain responses
    decoded = np.logical_xor(encoded[:args.batch_size], bit_guess)
    
    # Training set generated by Eve
    train_crps = ChallengeResponseSet(
        args.n_bits,
        challenges[batch*args.batch_size:(batch+1)*args.batch_size],
        np.array((decoded*2) - 1, dtype=np.float64))
    
    # ML model used by Eve
    model = pypuf.attack.MLPAttack2021(
        train_crps, seed=args.seed, net=[8,16,8], epochs=30, lr=.001,
        bs=1000, early_stop=.08)
    
    model.fit()
    
    # Test the model
    pred_y = model._model.eval(test_x)
    accuracies.append(np.count_nonzero(((pred_y<0.5) + test_y)-1)/len(test_y))
    
    ## -- Step 3: Iteratively improve the prediction accuracy of the model
    
    batch += 1
    while(batch < n_batches):
        
        # Response prediction by Eve
        response_guess = model._model.eval(
            challenges[:(batch+1)*args.batch_size])
        
        # Random bits guessed by Eve
        bit_guess = rng.integers(low=0, high=2, size=(batch+1)*args.batch_size)
        
        # Bits decoded by Eve to obtain responses
        decoded = np.logical_xor(
            encoded[:(batch+1)*args.batch_size], bit_guess)
        
        # Training set generated by Eve with only the accurate responses with
        # high probability
        idx = np.where(decoded == bit_guess)[0]
        train_crps = ChallengeResponseSet(
            args.n_bits, challenges[idx],
            np.array(response_guess[idx], dtype=np.float64))
        
        # New ML model used by Eve
        model = pypuf.attack.MLPAttack2021(
            train_crps, seed=args.seed, net=[8,16,8], epochs=30, lr=.001,
            bs=1000, early_stop=.08)
        
        model.fit()
        
        # Test the model
        pred_y = model._model.eval(test_x)
        accuracies.append(np.count_nonzero(((pred_y<0.5) + test_y)-1)/len(test_y))
        
        ## -- Step 4: Attempt to decode the key (100% accuracy)
        
        if(accuracies[-1] == 1):
            break
        
        batch += 1
    
    # Calculate the uniformity for the responses
    uniformity = np.count_nonzero(responses+1)/len(responses)
    
    # Log data into csv format
    data = pd.DataFrame({"seed": [args.seed],
                         "n_bits": [args.n_bits],
                         "k": [args.k],
                         "train_data": [args.train_data],
                         "test_data": [args.test_data],
                         "batch_size": [args.batch_size],
                         "n_batches": [batch],
                         "uniformity": [uniformity],
                         "accuracies": [accuracies],
                         "final_accuracy": [accuracies[-1]]})
    filepath = Path(
        args.outdir + "out_PUQKD_random_" + str(args.k) + "XOR.csv")
    if(filepath.is_file()):
        data.to_csv(filepath, header=False, index=False, mode='a')
    else:
        filepath.parent.mkdir(parents=True, exist_ok=True)
        data.to_csv(filepath, header=True, index=False, mode='a')
    

if(__name__ == "__main__"):
    main()

